"""
Main FastAPI application for LifeHackAI.
"""
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
import os
from typing import List, Optional
from datetime import datetime, timedelta

from .models import (
    ProblemCreate, 
    ProblemResponse, 
    PlanResponse, 
    TaskCreate, 
    TaskResponse,
    TaskUpdate
)
from .plans import generate_plan
from .tasks import TaskManager
from .store import get_db, init_db

# Initialize FastAPI app
app = FastAPI(
    title="LifeHackAI API",
    description="AI-powered daily life problem solver with smart plans and automation",
    version="0.1.0"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # For development; restrict in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize task manager
task_manager = TaskManager()

# Initialize database on startup
@app.on_event("startup")
async def startup_event():
    init_db()

# API Routes
@app.get("/")
async def root():
    """Root endpoint with API information."""
    return {
        "name": "LifeHackAI API",
        "version": "0.1.0",
        "status": "active",
        "docs_url": "/docs"
    }

@app.get("/problems", response_model=List[ProblemResponse])
async def list_problems(db=Depends(get_db)):
    """List all available problems."""
    # In a real app, this would query the database
    return [
        ProblemResponse(
            id=1,
            title="Weekly grocery shopping optimization",
            category="shopping",
            description="Save time and money on groceries",
            created_at=datetime.now().isoformat()
        ),
        ProblemResponse(
            id=2,
            title="Daily productivity routine",
            category="productivity",
            description="Establish a morning routine for better productivity",
            created_at=datetime.now().isoformat()
        ),
        ProblemResponse(
            id=3,
            title="Monthly budget planning",
            category="finance",
            description="Create and stick to a personal budget",
            created_at=datetime.now().isoformat()
        )
    ]

@app.post("/problems", response_model=ProblemResponse, status_code=201)
async def create_problem(problem: ProblemCreate, db=Depends(get_db)):
    """Create a new problem."""
    # In a real app, this would insert into the database
    new_problem = ProblemResponse(
        id=4,  # In real app, this would be generated by the database
        title=problem.title,
        category=problem.category,
        description=problem.description,
        created_at=datetime.now().isoformat()
    )
    return new_problem

@app.get("/problems/{problem_id}", response_model=ProblemResponse)
async def get_problem(problem_id: int, db=Depends(get_db)):
    """Get a specific problem by ID."""
    # In a real app, this would query the database
    if problem_id not in [1, 2, 3, 4]:
        raise HTTPException(status_code=404, detail="Problem not found")
    
    return ProblemResponse(
        id=problem_id,
        title=f"Sample Problem {problem_id}",
        category="general",
        description=f"Description for problem {problem_id}",
        created_at=datetime.now().isoformat()
    )

@app.post("/problems/{problem_id}/plan", response_model=PlanResponse)
async def create_plan_for_problem(problem_id: int, db=Depends(get_db)):
    """Generate an AI plan for a specific problem."""
    # Check if problem exists
    if problem_id not in [1, 2, 3, 4]:
        raise HTTPException(status_code=404, detail="Problem not found")
    
    # Generate plan using AI
    plan = generate_plan(problem_id)
    return plan

@app.get("/plans/{plan_id}", response_model=PlanResponse)
async def get_plan(plan_id: int, db=Depends(get_db)):
    """Get a specific plan by ID."""
    # In a real app, this would query the database
    if plan_id != 1:
        raise HTTPException(status_code=404, detail="Plan not found")
    
    return generate_plan(1)  # Using the same generator for demo

@app.post("/plans/{plan_id}/tasks", response_model=TaskResponse, status_code=201)
async def create_task(plan_id: int, task: TaskCreate, db=Depends(get_db)):
    """Create a new task from a plan."""
    # Check if plan exists
    if plan_id != 1:
        raise HTTPException(status_code=404, detail="Plan not found")
    
    # Create task
    due_at = datetime.now() + timedelta(hours=2)  # Default due time
    if task.due_at:
        due_at = datetime.fromisoformat(task.due_at)
    
    task_id = task_manager.add_task(
        plan_id=plan_id,
        title=task.title or "New Task",
        due_at=due_at.isoformat()
    )
    
    return TaskResponse(
        id=task_id,
        plan_id=plan_id,
        title=task.title or "New Task",
        due_at=due_at.isoformat(),
        status="pending"
    )

@app.get("/tasks", response_model=List[TaskResponse])
async def list_tasks(db=Depends(get_db)):
    """List all tasks."""
    return task_manager.get_all_tasks()

@app.get("/tasks/{task_id}", response_model=TaskResponse)
async def get_task(task_id: int, db=Depends(get_db)):
    """Get a specific task by ID."""
    task = task_manager.get_task(task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return task

@app.patch("/tasks/{task_id}", response_model=TaskResponse)
async def update_task(task_id: int, task_update: TaskUpdate, db=Depends(get_db)):
    """Update a task's status."""
    task = task_manager.update_task(task_id, task_update.status)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return task

@app.post("/tasks/{task_id}/complete", response_model=TaskResponse)
async def complete_task(task_id: int, db=Depends(get_db)):
    """Mark a task as complete."""
    task = task_manager.update_task(task_id, "completed")
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return task

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)